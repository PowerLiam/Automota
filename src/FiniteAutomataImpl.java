import java.util.*;

/**
 * Represents a FiniteAutomata (deterministic or non-deterministic).  Spawns asynchronous threads to handle
 * nondeterministic branching, and returns all of the accept states generated by the input.  To use, first create an
 * instance of FiniteAutomataImpl, then call setString() to prime the input, and finally call compute().
 */
public class FiniteAutomataImpl implements FiniteAutomata {
    // Threads of branching computations below this FiniteAutomata.
    private Map<FiniteAutomataImpl, Thread> executeThreads;
    // All the states of the FiniteAutomata.
    private final List<State> STATES;
    // The current state of the FiniteAutomata.
    private State currentState;
    // The input still to be ingested.
    private String inputStr;
    // If true, this FiniteAutomata has died, and its currentState should be ignored.
    private boolean hasDied;
    // If true, this FiniteAutomata, as well as any FiniteAutomata this has spawned have completed execution.
    private boolean hasFinished;
    // Thread ID
    private int TID;
    // Thread ID assigner value.
    public static int TID_count = 0;

    /**
     * Create a new FiniteAutomata, allowing it to determine the start state from the input.
     * @param states All the states.
     * @param TID Thread ID.
     */
    public FiniteAutomataImpl(List<State> states, int TID) {
        this.STATES = states;
        for (State state : STATES) {
            if (state instanceof Start) {
                if (currentState != null) {
                    System.err.println("Found multiple start states when creating Automata.");
                    System.exit(0);
                }
                currentState = state;
            }
        }
        if (currentState == null) {
            System.err.println("Could not find start state implicitly in args when creating Automata.");
            System.exit(0);
        }
        this.executeThreads = new HashMap<>();
        this.hasDied = false;
        this.hasFinished = false;
        this.TID = TID;
    }

    /**
     * Create a new FiniteAutomata that starts from a given state, which must be inside the list of states.
     * @param states The states of the FiniteAutomata.
     * @param currentState The current state, must be within states.
     * @param TID Thread ID.
     */
    public FiniteAutomataImpl(List<State> states, State currentState, int TID) {
        this.STATES = states;
        if (!STATES.contains(currentState)) {
            System.err.println(TID + ": Invalid start state, cannot find start state in state list");
            System.exit(0);
        }
        this.executeThreads = new HashMap<>();
        this.currentState = currentState;
        this.hasDied = false;
        this.hasFinished = false;
        this.TID = TID;
    }


    @Override
    public List<State> compute() {
        // Do the threaded work.
        this.run();
        // Wait till I have finished (and thus all my children have finished.
        while(!this.hasFinished) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        // Go get all the AcceptStates along the tree of FiniteAutomata that have been executed and haven't died.
        List<State> ret = new ArrayList<>();
        // See if I myself have completed execution and am on a final state.
        if (!this.hasDied && this.currentState instanceof Accept) {
            ret.add(currentState);
        }
        // Get all other AcceptStates that Automata I spawned have fallen into.
        getStates(this.executeThreads.keySet(), ret);
        return ret;
    }

    private void getStates(Set<FiniteAutomataImpl> autos, List<State> acc) {
        // For each Automata I spawned....
        // System.out.println(TID + ": ---------------------");
        for (FiniteAutomataImpl cur: autos) {
            // See if it had a nice ending state.
            // System.out.println(TID + ": " + cur.currentState.getName());
            if (!cur.hasDied && cur.currentState instanceof Accept) {
                    acc.add(cur.currentState);
            }
            // Look at all the FiniteAutomata that cur spawned.
            getStates(cur.executeThreads.keySet(), acc);
        }
    }

    /**
     * Should NOT BE CALLED DIRECTLY FROM OUTSIDE THIS CLASS.  This the the method used to make Threads for
     * computational branches, and is called from compute().
     */
    @Override
    public void run() {
        if (!validate(STATES)) {
            System.err.println(TID + ": Invalid list of states, maybe duplicate name or start state?");
            System.exit(0);
        }
        // Parse the entire input of this FiniteAutomata, spawning threads for any non-deterministic branches.
        parseMyStr();

        // Now that this Automata has finished processing input we need to decide if is "finished", and
        // wait if not.  A FiniteAutomata hasFinished when it is done processing its input and ALL branches it spawned
        // have finished.

        // If I had no children and finished parsing my String, I am DONE (No children to wait on, all input
        // ingested)
        if (executeThreads.keySet().size() == 0) {
            hasFinished = true;
            //METHOD EXIT 2: SUCCESS NO CHILDREN
            return;
        }
        // Wait here for ALL children to finish.
        waitForChildren();
        // Now I am truly finished (I am done and all my children are done), and can finally bail out of execution.
        this.hasFinished = true;
        //METHOD EXIT 3: SUCCESS, CHILDREN FINISHED
    }

    // Wait for all children to finish processing.
    private void waitForChildren() {
        // firstPass allows us to not spin the CPU if we are waiting for a slow child, but still be fast if all children
        // are done initially.
        boolean firstPass = true;
        boolean childrenFinished;
        do {
            childrenFinished = true;
            for (FiniteAutomataImpl check : executeThreads.keySet()) {
                childrenFinished &= check.hasFinished;
            }
            if (!firstPass) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            firstPass = false;
        } while (!childrenFinished);
    }

    // Parse the entire input of this FiniteAutomata, spawning threads for any non-deterministic branches.
    private void parseMyStr() {
        // Main loop
        int index;
        char[] strArr = inputStr.toCharArray();
        // Loop through all the input.
        for (index = 0; index < strArr.length; index++) {
            // Map that contains all applicable Transitions as well as information about whether they are returned
            // due to an empty input (wild card)
            Map<Transition, Boolean> transitionMap = currentState.getTransitions(strArr[index]);
            // Just the list of applicable Transitions.
            List<Transition> transitionList = new ArrayList<>(transitionMap.keySet());
            // No transitions for my input?  This branch is invalid, die and ignore my state forever.
            if (transitionMap.size() == 0) {
                hasDied = true;
                hasFinished = true;
                // METHOD EXIT 1: I DIED.
                return;
            } else if (transitionMap.size() == 1) { // One Transition, just power on through.
                currentState = transitionList.get(0).getDest();
                // We are progressing with a wild card.
                if (transitionMap.get(transitionList.get(0))) {
                    index--; //Don't consume a character from the input if we progress due to an empty (wild card)!
                }
            } else { // Multiple Transitions, nondeterministic branching time!
                // Progress the main line (this Automata)
                currentState = transitionList.get(0).getDest();
                // Remove that Transition (since we don't branch with it)
                transitionMap.remove(transitionList.get(0));
                transitionList.remove(0);
                // For all other Transitions we will need to branch.
                for (Transition t : transitionList) {
                    //Spawn an execute thread for each Transition.
                    FiniteAutomataImpl spawn = new FiniteAutomataImpl(STATES, t.getDest(), ++TID_count);
                    // Decide what to provide as input to the new Automata branch.
                    //  1. If we are progressing from a wild card we don't consume any chars, so provide the
                    //     same string.
                    //  2. If we are on the last char, provide an empty string as we consume it (CRUCIAL to still follow
                    //     this branch, as it might land on an accept state!!!)
                    //  3. If we are somewhere normal in the input, just consume the first char and pass the rest.
                    if (transitionMap.get(t)) {
                        spawn.setString(inputStr);
                    } else if (index + 1 == inputStr.length()) {
                        spawn.setString("");
                    } else {
                        spawn.setString(inputStr.substring(index + 1, inputStr.length()));
                    }
                    // Make the thread and execute it.
                    Thread execute = new Thread(spawn);
                    executeThreads.put(spawn, execute);
                    execute.run();
                }
            }
        }
    }

    public void setString(String s) {
        this.inputStr = s;
    }

    /**
     * Validates that a given list of States can legally represent a FiniteAutomata.
     * @param states A list of all the states.
     * @return A boolean representing the validity of a FiniteAutomata with those States.
     */
    private boolean validate(List<State> states) {
        boolean start = false;
        Map<String, State> validateNames = new HashMap<>();
        List<Transition> validateTransitions = new ArrayList<>();
        for(State s : states) {
            // Ensure exactly one start state.
            if (s instanceof Start) {
                if (start) {
                    return false;
                }
                start = true;
            }
            // Ensure no duplicate State names.
            if (validateNames.containsKey(s.getName())) {
                return false;
            }
            validateNames.put(s.getName(), s);

            //Ensure no duplicate Transitions.
            for(Transition t : s.getTransitions()) {
                if (validateTransitions.contains(t)) {
                    return false;
                }
                validateTransitions.add(t);
            }
        }
        if (!start) {
            return false;
        }
        return true;
    }
}
